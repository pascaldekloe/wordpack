// Code generated by packgen(1); DO NOT EDIT.

package {{ .PackageName }}

import "io"

{{- $word := printf "uint%d" .WordWidth }}

func appendDeltaPackNBit[T ~int | ~int32 | ~int64 | ~uint64](dst []{{ $word }}, src *[{{ .WordWidth }}]T, bitN int, offset T) []{{ $word }} {
	switch bitN {
	case 0:
		return dst // nop
{{ range .BitPacks }}	case {{ .BitN }}:
		return appendDeltaPack{{ .BitN }}Bit(dst, src, offset)
{{ end }}	default:
		return append(dst{{ range $index, $number := iterate .WordWidth }}, {{ $word }}(src[{{ $index }}]){{ end }})
	}
}

func appendDeltaUnpackNBit[T ~int | ~int32 | ~int64 | ~uint64](dst []T, src []{{ $word }}, bitN int, offset T) ([]T, error) {
	switch bitN {
	case 0:
		return append(dst{{ range iterate .WordWidth }}, offset{{ end }}), nil
{{ range .BitPacks }}	case {{ .BitN }}:
		if len(src) < {{ .BitN }} {
			return nil, io.ErrUnexpectedEOF
		}
		return appendDeltaUnpack{{ .BitN }}Bit(dst, (*[{{ .BitN }}]{{ $word }})(src), offset), nil
{{ end }}	default:
		return append(dst{{ range $index, $number := iterate .WordWidth }}, T(src[{{ $index }}]){{ end }}), nil
	}
}
{{ range .BitPacks }}
func appendDeltaPack{{ .BitN }}Bit[T ~int | ~int32 | ~int64 | ~uint64](dst []{{ $word }}, src *[{{ .WordWidth }}]T, offset T) []{{ $word }} {
	return append(dst,
{{ range .BitPackExpressions .DeltaEncodeExpressions }}		{{ . }},
{{ end }}	)
}
{{ end }}
{{- range .BitPacks }}
func appendDeltaUnpack{{ .BitN }}Bit[T ~int | ~int32 | ~int64 | ~uint64](dst []T, src *[{{ .BitN }}]{{ $word }}, offset T) []T {
{{ range $index, $expr := .BitUnpackExpressions }}	offset -= T((int64({{ $expr }}) >> 1) ^ (-(int64({{ $expr }}) & 1)))
	out{{ $index }} := offset
{{ end}}
	return append(dst{{ range $index, $expr := .BitUnpackExpressions }}, out{{ $index }}{{ end }})
}
{{- end }}
