// Code generated by packgen(1); DO NOT EDIT.

package {{ .PackageName }}

import (
	"io"
	"math/bits"
)

{{- $word := printf "uint%d" .WordWidth }}

// AppendDeltaPack encodes the difference of each consecutive value in src. The
// first value in src is compared against offset. Use src[0] as offset when
// first in line.
func AppendDeltaPack[T ~int | ~int32 | ~int64 | ~uint64](dst []{{ $word }}, src *[{{ .WordWidth }}]T, offset T) []{{ $word }} {
	// collect bits in use by all deltas (zig-zag encoded) combined
	d0 := int64(offset - src[0])
	mask := (d0 << 1) ^ (d0 >> 63)
{{ range $index, $value := iterate 63}}	d{{ $value }} := int64(src[{{ $index }}] - src[{{ $value }}])
	mask |= (d{{ $value }} << 1) ^ (d{{ $value }} >> 63)
{{ end }}
	return appendDeltaPackNBit(dst, src, bits.Len64(uint64(mask)), offset)
}

func appendDeltaPackNBit[T ~int | ~int32 | ~int64 | ~uint64](dst []{{ $word }}, src *[{{ .WordWidth }}]T, bitN int, offset T) []{{ $word }} {
	switch bitN {
	case 0:
		return dst // nop
{{ range .BitPacks }}	case {{ .BitN }}:
		return appendDeltaPack{{ .BitN }}Bit(dst, src, offset)
{{ end }}	default:
		return append(dst{{ range $index, $number := iterate .WordWidth }}, {{ $word }}(src[{{ $index }}]){{ end }})
	}
}

// AppendDeltaUnpackNBit decodes an output from an appendDeltaPack as src. The
// offsets must match.
func AppendDeltaUnpack[T ~int | ~int32 | ~int64 | ~uint64](dst []T, src []{{ $word }}, offset T) ([]T, error) {
	switch len(src) {
	case 0:
		return append(dst{{ range iterate .WordWidth }}, offset{{ end }}), nil
{{ range .BitPacks }}	case {{ .BitN }}:
		if len(src) < {{ .BitN }} {
			return nil, io.ErrUnexpectedEOF
		}
		return appendDeltaUnpack{{ .BitN }}Bit(dst, (*[{{ .BitN }}]{{ $word }})(src), offset), nil
{{ end }}	default:
		return append(dst{{ range $index, $number := iterate .WordWidth }}, T(src[{{ $index }}]){{ end }}), nil
	}
}
{{ range .BitPacks }}
func appendDeltaPack{{ .BitN }}Bit[T ~int | ~int32 | ~int64 | ~uint64](dst []{{ $word }}, src *[{{ .WordWidth }}]T, offset T) []{{ $word }} {
	return append(dst,
{{ range .BitPackExpressions .DeltaEncodeExpressions }}		{{ . }},
{{ end }}	)
}
{{ end }}
{{- range .BitPacks }}
func appendDeltaUnpack{{ .BitN }}Bit[T ~int | ~int32 | ~int64 | ~uint64](dst []T, src *[{{ .BitN }}]{{ $word }}, offset T) []T {
{{ range $index, $expr := .BitUnpackExpressions }}	offset -= T((int64({{ $expr }}) >> 1) ^ (-(int64({{ $expr }}) & 1)))
	out{{ $index }} := offset
{{ end}}
	return append(dst{{ range $index, $expr := .BitUnpackExpressions }}, out{{ $index }}{{ end }})
}
{{- end }}
